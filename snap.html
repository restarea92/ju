<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollToPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/FilterBlurPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomEase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/DrawSVGPlugin.min.js"></script>
    <link rel="stylesheet" href="https://restarea92.github.io/ju/project/static/css/custom_style.css">
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css" />
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css" />
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>
<body>
<style>
	body, html {
        margin: 0;
		overflow-x: clip;
        font-size: 17px;
        font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, Roboto, "Helvetica Neue", "Segoe UI", "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }
    * {
        box-sizing: border-box;
    }
</style>



<!-- Document Root Style -->
<style>
	:root {
		--gradient-primary: linear-gradient(45deg, #667eea, #764ba2);
		--shadow-hover: 0 20px 40px rgba(102, 126, 234, 0.3);
		--border-glass: 1px solid rgba(255, 255, 255, 0.1);
		--bg-glass: rgba(255, 255, 255, 0.05);
		--backdrop-blur: blur(20px);
		--transition-smooth: all 0.3s ease;
		--title-overlay-scale: 2;
    
        /* Typography Scale in this page only */
        --font-h1: 3.5rem;
        --font-h2: 2.5rem;
        --font-h3: 1.75rem;
        --font-big: 1.25rem;
        --font-body: 1.125rem;
        --font-small: 1rem;
		--font-size-typography: 2rem;
        /* Typography Scale in common pages */
        --font-size-primary-title: 4rem;
        --font-size-common-title: 3rem;
        --font-size-sub-title: 1.5rem;
	}
@media (max-width: 1280px) and (min-width: 1025px) {
    /* 1025 ~ 1280 */
    :root {        
        --font-size-primary-title: 3rem;
        --font-size-common-title: 2.5rem;
        --font-size-sub-title: 1.5rem;
    }
}

@media (max-width: 1024px) and (min-width: 769px) {
/* 769 ~ 1024 */
    :root {    
        --font-size-primary-title: clamp(2.5rem, max(5lvh, 5lvw), 3rem);
        --font-size-common-title: 2rem;
        --font-size-sub-title: clamp(1.125rem, max(3lvh, 3lvw), 1.25rem);
		--font-size-typography: 1.75rem;
    }
}

@media (max-width: 768px) {
    :root {   
		--font-big: 1.125rem;
        --font-size-common-title: 1.75rem;
        --font-size-primary-title: clamp(2rem, max(5lvh, 5lvw), 2.5rem);
        --font-size-sub-title: clamp(1rem, max(3lvh, 3lvw), 1.125rem);
		--font-size-typography: 1.5rem;
    }
}

</style>

<!-- Override Common Container Style-->
<style>
/* 공통 컨테이너 스타일 */
.common-container {
	position: relative;
	z-index: 1;
	padding: 4rem 0;
    
	h2, h3, h4, h5 {
		margin: 0;
	}

	.content-wrapper {
        width: 100%;
		display: block;
        padding: 0 calc(var(--default-container-padding) / 2);
        max-width: var(--default-container-width);
		margin: 0 auto;
	}
    
	.content {
		background:unset;
		display: block;
	}

	.content-title {
		word-break: keep-all;
		font-size: var(--font-size-primary-title);
		font-weight: 800;
		text-align: center;
		margin-bottom: 4rem;
		color: var(--common-text-color);
		position: relative;
	}
	
	h2, h3 {
        font-weight: 800;
	}
}
</style>



<script type="module">
/**
 * Visual Scroll Animation Module
 * Handles scroll-triggered visual effects with GSAP and ScrollTrigger
 * @version 1.0.7
 */

import { initGSAP } from 'https://restarea92.github.io/ju/modules/gsapUtils.js';

const app = {
    // ========== Configuration ==========
    CONFIG: {
        VERSION: '1.0.0',
    },

    // ========== DOM Elements Cache ==========
    elements: {
        spacer: document.querySelector('.hero-spacer'),
		container: document.querySelector('.business.common-container'),
		get trigger() { return this.spacer },
		get fixedWrapper() { return this.trigger?.querySelector('.fixed-wrapper'); },
		get content() { return this.trigger?.querySelector('.content')},
		get contentWrapper() { return this.trigger?.querySelector('.content-wrapper')},

		get contentTitle() {return this.trigger?.querySelector('.content-title')},
		get contentTitleText() { return this.trigger?.querySelector('.content-title-text')},

        get heroIntroCopyWrapper() { return this.trigger?.querySelector('.hero-intro-copy-wrapper'); },
        get heroIntroCopy() { return this.heroIntroCopyWrapper?.querySelector('.hero-intro-copy'); },
        get heroIntroCopyInner() { return this.heroIntroCopy?.querySelector('.hero-intro-copy-inner'); },

        get overlayBackground() { return this.trigger?.querySelector('.overlay-background'); },
    },
	
    // ========== Initialization ==========
	init() {
		if (!initGSAP()) return;

		this.setHeaderHeightVariable();
		this.initHeroScroll();

		let resizeTimer;
		let isTouching = false;

		// 모바일 터치 감지 (pinch zoom 포함)
		window.addEventListener("touchstart", () => {
			isTouching = true;
		});

		window.addEventListener("touchend", () => {
			setTimeout(() => { // 약간의 딜레이 후 터치 종료 처리
				isTouching = false;
			}, 500);
		});

		// 리사이즈 종료 감지 (디바운스)
		window.addEventListener("resize", () => {
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(() => {
				if (!isTouching) {
					this.setHeaderHeightVariable();
					this.initHeroScroll();
				}
			}, 300); 
		});
	},


    // ========== Hero Scroll Animation Setup ==========
    initHeroScroll() {
        // 기존 타임라인 kill
        if (this.tl) {
            this.tl.kill();
            this.tl = null;
        }

		const trigger = this.elements.trigger;
		const container = this.elements.container;
		const fixedWrapper = this.elements.fixedWrapper;
		const content = this.elements.content;
		const contentWrapper = this.elements.contentWrapper;
		const contentTitle = this.elements.contentTitle;
        const heroIntroCopyWrapper = this.elements.heroIntroCopyWrapper;
        const heroIntroCopy = this.elements.heroIntroCopy;
        const heroIntroCopyInner = this.elements.heroIntroCopyInner;
        const overlayBackground = this.elements.overlayBackground;
        
        if (trigger) {
			gsap.set(trigger, { 
				"--hero-scroll-inverted-progress": 1,
                "--hero-scroll-progress": 0,
				height: "clamp(2000px, 200svh, 3000px)",
			});

			gsap.set(container, { 
				marginTop: "calc(-1 * var(--header-height))",
			});
		
			gsap.set(fixedWrapper, { 
				width:"100%",
				minHeight:"100svh",
				position: "sticky",
			});

            gsap.set(contentTitle, {
                opacity: 1,
                filter: "blur(0px)",
            });

            gsap.set(overlayBackground, {
                filter: "blur(0px) brightness(1)",
            });

            gsap.set(heroIntroCopyInner, {
                opacity:0,
                yPercent: 100,
            });

			const fixedTop = parseFloat(getComputedStyle(container)
				.getPropertyValue('--fixed-wrapper-top')) || 0;


			this.tl = this.createTimeline({
				start: "top top",
				end: "bottom bottom+=10%",
                scrub: 0.3,
				onUpdate: self => {
					if (self.progress >= 1) {
						this.elements.container.classList.add('scroll-end');
					} else {
						this.elements.container.classList.remove('scroll-end');
					}
				}
			});

            this.tl.to(heroIntroCopyInner, {
				yPercent: 0,
			});

            this.createTimeline({
				start: "top top",
				end: "center top",
                scrub: 0.3,
			}).to(contentTitle, {
                ease: "expo.out",
                filter: "blur(16px)",
				opacity: 0,
			});

            this.createTimeline({
				start: "1% top",
				end: "center center",
                scrub: true,
			}).to(heroIntroCopyInner, {
                ease: "expo.out",
				opacity: 1,
			});

            this.createTimeline({
				start: "top top",
				end: "center top",
                scrub: 0.3,
			}).to(overlayBackground, {
                ease: "expo.out",
				filter: "blur(16px) brightness(0.25)",
			}, 0);

		} 
	},

    // ========== 상태 관리 ==========
    setHeaderHeightVariable() {
        const header = document.getElementById('doz_header_wrap');
        const headerHeight = header ? header.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--header-height', `${headerHeight}px`);
    },

    createTimeline(options = {}) {
        return gsap.timeline({
            scrollTrigger: {
                trigger: this.elements.trigger, 
                start: "top bottom",
                end: "bottom bottom",
                scrub: 1,
                onUpdate: self => {
                    // 필요한 경우 progress 활용 가능
                },
                ...options,
            }
        });
    },
}

document.addEventListener('DOMContentLoaded', () => {
	app.init();
});
</script>

<style>

.dashed-border {
    --dashed-border-color: #888;
    --default-dashed-border-width: 2px;
    box-shadow: inset 0 0 0 var(--dashed-border-width) var(--dashed-border-color);
    &.red { --dashed-border-color: rgba(255, 0, 0, 0.5); }
    &.blue { --dashed-border-color: rgba(0, 0, 255, 0.5); }
    &.green { --dashed-border-color: rgba(0, 128, 0, 0.5); }
    &.yellow { --dashed-border-color: rgba(255, 255, 0, 0.5); }
    &.orange { --dashed-border-color: rgba(255, 165, 0, 0.5); }
    &.purple { --dashed-border-color: rgba(128, 0, 128, 0.5); }
    &.black { --dashed-border-color: rgba(0, 0, 0, 0.5); }
    &.gray { --dashed-border-color: rgba(128, 128, 128, 0.5); }

    &.thickness2 { --dashed-border-width: calc(var(--default-dashed-border-width) * 2); }
    &.thickness3 { --dashed-border-width: calc(var(--default-dashed-border-width) * 3); }
    &.thickness4 { --dashed-border-width: calc(var(--default-dashed-border-width) * 4); }
    &.thickness5 { --dashed-border-width: calc(var(--default-dashed-border-width) * 5); }
}

.snap-scroll.common-container {
    --viewport-inset: 0;
    --snap-item-count: 0;
    --snap-visible-count: 0;
    --snap-gap: 2rem;
    --snap-padding: 2rem;
    --snap-list-inset: 0;
    --snap-item-width: 0;
    h2.content-title {
        text-align: left;
        margin: 0 auto;
        margin-bottom: 2rem;
        max-width: var(--default-container-width);
        padding: 0 var(--snap-padding);
    }
    .content-wrapper:not(.dummy) {
        position: relative;
        height: 75vh;
        padding: 0 var(--snap-padding);
        max-width: unset;
    }
    .content-wrapper {
        height: 0;
        padding: 0 var(--snap-padding);
    }
    .snap-container {
        width: calc(100%);
        height: 100%;
        position: absolute;
        left: 0;
        top: 0;
    }

    .snap-list {
        overflow-x: auto;
        scroll-snap-type: x proximity;
        opacity: 0.2;
        height: 100%;
        display: grid;
        gap: var(--snap-gap);
        grid-template-columns: repeat(var(--snap-item-count), 1fr);
        padding-left: var(--snap-list-inset);
        padding-right: var(--snap-list-inset);

        /* 아래 코드로 스크롤이 inset에서 멈춤 */
        scroll-padding-left: var(--snap-list-inset);
        scroll-padding-right: var(--snap-list-inset);

        .snap-item {
            width: var(--snap-item-width);
            background-color: gray;
            border-radius: 1.5rem;
            scroll-snap-align: start;
        }
    }
}
</style>



<div style="height: 100vh;">

</div>
<!-- Vision Section -->
<div class="snap-scroll common-container">
    <h2 class="content-title">Snap section title.</h2>
    <div class="content-wrapper dummy"></div>
	<div class="content-wrapper">
        <div class="snap-container">
            <div class="snap-list">
                <div class="snap-item"></div>
                <div class="snap-item"></div>
                <div class="snap-item"></div>
                <div class="snap-item"></div>
                <div class="snap-item"></div>
                <div class="snap-item"></div>
                <div class="snap-item"></div>
                <div class="snap-item"></div>
            </div>
        </div>
	</div>
</div>
<div style="height: 100vh;">

</div>


<script>
/**
 * Snap 영역 스타일 변수 업데이트 및 이벤트 처리
 * @module snapScroll
 */
document.addEventListener('DOMContentLoaded', () => {

    /** 기본 옵션 상수 정의
     * @constant {object} snapConfig
     */
    const snapConfig = {
        //고정
        VERSION: '1.0.0',
        SNAP_VISIBLE_COUNT: 2,
        SNAP_GAP: '2rem',
        SNAP_PADDING: '2rem',

        //동적
        VIEWPORT_INSET: 0,
        SNAP_ITEM_WIDTH: 0,
        SNAP_ITEM_COUNT: 0,
        SNAP_LIST_INSET: 0
    };


    /** @type {HTMLElement|null} */
    const snapScrollContainer = document.querySelector('.snap-scroll.common-container');
    /** @type {HTMLElement|null} */
    const dummyContentWrapper = document.querySelector('.snap-scroll .content-wrapper.dummy');
    /** @type {HTMLElement|null} */
    const contentWrapper = document.querySelector('.snap-scroll .content-wrapper');
    /** @type {HTMLElement|null} */
    const snapContainer = document.querySelector('.snap-container');
    /** @type {NodeListOf<HTMLElement>} */
    const snapItems = snapContainer ? snapContainer.querySelectorAll('.snap-item') : [];
    /** @type {HTMLElement|null} */
    const snapList = snapContainer ? snapContainer.querySelector('.snap-list') : null;


 
    
    const getContainerWidth = () => {
        /** @type {number} */
        const containerWidth = dummyContentWrapper ? dummyContentWrapper.getBoundingClientRect().width : 0;
        console.log('Container Width:', containerWidth);
        return containerWidth;
    };

    const getContentWidth = () => {
        /** @type {number} */
        const contentWidth = getContainerWidth() - anyToPx(snapConfig.SNAP_PADDING) * 2;
        console.log('Content Width:', contentWidth);
        return contentWidth;
    };

    const getSnapItemWidth = () => {
        const visibleCount = snapConfig.SNAP_VISIBLE_COUNT;
        const snapGap = anyToPx(snapConfig.SNAP_GAP);

        const contentWidth = getContentWidth();
        const baseContentWidth = contentWidth - snapGap * (visibleCount - 1);
        const snapItemWidth = baseContentWidth / visibleCount;

        return snapItemWidth;
    };

    /**
     * Get viewport inset
     * @returns {number}
     */
    const getViewportInset = () => {
        const contentWidth = getContentWidth();
        const viewportWidth = document.body.getBoundingClientRect().width;
        const inset = (viewportWidth - contentWidth) / 2;
        return inset;
    };

    /**
     * Get snap list inset
     * @returns {number}
     */
    const getSnapListInset = () => {
        const snapListInset = getViewportInset();
        return snapListInset;
    };


   const setSnapConfig = () => {
        if (!snapScrollContainer || !dummyContentWrapper || !contentWrapper || !snapContainer) return;
        Object.assign(snapConfig, {
            SNAP_ITEM_WIDTH: `${getSnapItemWidth()}px`,
            SNAP_ITEM_COUNT: snapItems.length,

            VIEWPORT_INSET: `${getViewportInset()}px`,
            SNAP_LIST_INSET: `${getSnapListInset()}px`,
        });
    };

    /**
     * snap 관련 스타일 변수 업데이트
     * @returns {void}
     */
    const updateSnapProperty = () => {
        if (!snapContainer) return;
        // 기본 스타일 변수 설정
        snapContainer.style.setProperty('--snap-visible-count', `${snapConfig.SNAP_VISIBLE_COUNT}`);
        snapContainer.style.setProperty('--snap-gap', snapConfig.SNAP_GAP);
        snapContainer.style.setProperty('--snap-padding', snapConfig.SNAP_PADDING);
        snapContainer.style.setProperty('--snap-item-count', snapConfig.SNAP_ITEM_COUNT);
        snapContainer.style.setProperty('--viewport-inset', `${snapConfig.VIEWPORT_INSET}`);
        snapContainer.style.setProperty('--snap-item-width', `${snapConfig.SNAP_ITEM_WIDTH}`);
        snapContainer.style.setProperty('--snap-list-inset', `${snapConfig.SNAP_LIST_INSET}`);
    };




    /** -------------------------------------------------------------------------- 
     * 유틸리티 함수 모음
     */

    /**
     * rem 단위를 px로 변환하는 함수
     * @param {string} value - 
     * @returns {number} - px 단위 값
     */
    const anyToPx = (value) => {
        if (typeof value !== 'string') return 0;
        const initStyle = {
            width: 0,
            height: 0,
            visibility: 'hidden',
            opacity: 0,
            zIndex: -9999,
            position: 'absolute',
            letterSpacing: value,
            userSelect: 'none',
            touchAction: 'none',
            pointerEvents: 'none',
        }
        const tempElement = document.createElement('div');
        Object.assign(tempElement.style, initStyle);
        document.body.appendChild(tempElement);
        const pxValue = parseFloat(getComputedStyle(tempElement).letterSpacing) || 0;
        document.body.removeChild(tempElement);
        return pxValue;
    }

    /** -------------------------------------------------------------------------- */
    /* 디버그 함수 모음 */
    /**
     * 중앙선 추가
     * @returns {void}
     */
    const addGuideline = () => {
        const verticalLine = {
            center: document.createElement('div'),
            left: document.createElement('div'),
            right: document.createElement('div'),
        }
        Object.entries(verticalLine).forEach(([key, line]) => {
            line.style.position = 'fixed';
            line.style.top = '0';
            line.style.height = '100%';
            line.style.zIndex = '9999';
            line.style.pointerEvents = 'none';
            line.style.width = '1px';
            line.style.backgroundColor = 'aqua';
            line.style.opacity = '0.9';
            if (key === 'center') {
                line.style.left = '50%';
                line.style.transform = 'translateX(-50%)';
            } else if (key === 'left') {
                line.style.left = `${getViewportInset()}px`;
            } else if (key === 'right') {
                line.style.right = `${getViewportInset()}px`;
            }
            document.body.appendChild(line);
        });
    };
     
    /** debug
     * @param {boolean} isEnabled
     * @returns {void}
     */
    const debugSnapVariables = (isEnabled) => {
        if (!isEnabled) return;
        contentWrapper.classList.add('dashed-border', 'blue', 'thickness4');
        snapContainer.classList.add('dashed-border', 'red', 'thickness2');
        snapItems.forEach(item => item.classList.add('dashed-border', 'orange', 'thickness4'));
        addGuideline();
    };


    /**
     * 이벤트 리스너 등록
     * @returns {void}
     */
    const addEventListeners = () => {
        window.addEventListener('resize', updateSnapProperty);
        window.addEventListener('load', updateSnapProperty);
    };

    /**
     * 초기화 함수
     * @returns {void}
     */
    const init = () => {
        setSnapConfig();
        updateSnapProperty();
        debugSnapVariables(true);
        addEventListeners();
    };
    init();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // 기존 스크롤 애니메이션 코드
    const options = {
        observerOptions: {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        },
        transformYOffset: 30 // 예: transform: translateY(100px) 고려용
    };

	const observer = new IntersectionObserver(function(entries) {
		entries.forEach(entry => {
			const el = entry.target;

			if (entry.isIntersecting) {
				if (!el.classList.contains('visible')) {
					el.classList.add('visible');
				}

			} else {
				const elementTop = entry.boundingClientRect.top;
				const viewportTop = entry.rootBounds.top;

				// 아래로 스크롤해 나간 경우에만 클래스 제거
				if (elementTop > viewportTop) {
					el.classList.remove('visible');
				}
			}
		});
	}, options.observerOptions);

	document.querySelectorAll('.fade-in').forEach(el => {
		const rect = el.getBoundingClientRect();
		console.log(rect.bottom);
		if (rect.bottom < 0) {
			el.classList.add('visible');
		}

		// 관찰 시작
		observer.observe(el);
	});

});
</script>


</body>
</html>